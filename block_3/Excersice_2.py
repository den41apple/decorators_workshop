"""
Задача 2

2.1 Написать декоратор, который внутри себя выполнял бы функцию и возвращал бы результат её работы
    в случае успешного выполнения. В случае возникновения ошибки во время выполнения функции нужно сделать так,
    чтобы выполнение функции было повторено ещё раз с теми же самыми аргументами, но не более 10 раз.
    Если после последней попытки функцию так и не удастся выполнить успешно, то бросать исключение.

2.2 Параметризовать декоратор таким образом, чтобы количество попыток выполнения функции можно было
    задавать как параметр во время декорирования.
"""
from typing import Callable, Any


# 2.1 Написать декоратор, который внутри себя выполнял бы функцию и возвращал бы результат её работы
#     в случае успешного выполнения. В случае возникновения ошибки во время выполнения функции нужно сделать так,
#     чтобы выполнение функции было повторено ещё раз с теми же самыми аргументами, но не более 10 раз.
#     Если после последней попытки функцию так и не удастся выполнить успешно, то бросать исключение.

def retry_deco(func: Callable) -> Callable:
    cnt = 0  # Счетчик кол-ва запусков

    def wrapper(*args, **kwargs) -> Any:
        nonlocal cnt
        cnt += 1  # Увеличиваем счетчик при каждом запуске
        try:
            print(f"Запуск функции {cnt} раз")
            return func(*args, **kwargs)
        except Exception as err:
            if cnt == 10:
                raise err  # Бросаем исключение при 10-и попытках
            return wrapper(*args, **kwargs)

    return wrapper


@retry_deco
def some_func():
    """Функция для декорирования"""
    raise ValueError


if __name__ == "__main__":
    some_func()


# 2.2 Параметризовать декоратор таким образом, чтобы количество попыток выполнения функции можно было
#     задавать как параметр во время декорирования.

def retry(max_launches: int) -> Callable:
    def retry_deco(func: Callable) -> Callable:
        cnt = 0  # Счетчик кол-ва запусков

        def wrapper(*args, **kwargs) -> Any:
            nonlocal cnt
            cnt += 1  # Увеличиваем счетчик при каждом запуске
            try:
                print(f"Запуск функции {cnt} раз")
                return func(*args, **kwargs)
            except Exception as err:
                if cnt == max_launches:
                    raise err  # Бросаем исключение при n попытках
                return wrapper(*args, **kwargs)

        return wrapper

    return retry_deco


@retry(max_launches=5)
def some_func():
    """Функция для декорирования"""
    raise ValueError


if __name__ == "__main__":
    some_func()
